import 'reflect-metadata';

export class Container
{
	static instance: Container = undefined;

	private instances: Map<any, any> = new Map<any, any>();
	private parent: Container;


	constructor()
	{
		this.set( Container, this );
	}
	

	get( key: any ): any
	{
		// Find instance in instance-map
		
		const resolver: Resolver = ( key instanceof Resolver ) ? key : Singleton.of( key );
		let instance: any = resolver.resolve( this );


		// Create a new instance, if we haven't found one

		if ( ! instance )
		{
			instance = this.createInstance( key );
			this.instances.set( key, instance );
		}

		return instance;
	}


	set( key: any, value: any ): any
	{
		this.instances.set( key, value );
		return value;
	}


	has( key: any ): boolean
	{
		return this.instances.has( key );
	}


	getInstance( key: any ): any
	{
		return this.instances.get( key );
	}


	setRoot(): void
	{
		Container.instance = this;
	}


	isRoot(): boolean
	{
		return this === Container.instance;
	}


	setParent( parentContainer: Container ): void
	{
		this.parent = parentContainer;
	}


	getParent(): Container
	{
		return this.parent;
	}


	createInstance( target: any ): any
	{
		let instance: any;

		if ( typeof target !== 'function')
		{
			console.log( target );
			throw new Error( 'Container cannot make instance of non-function!' );
		}

		try
		{
			let dependencies: any[] = [];

			if ( target.__inject && Array.isArray( target.__inject ) )
			{
				dependencies = target.__inject.map( x => this.get( x ) );
			}

			instance = new target( ...dependencies );
		}

		catch ( e )
		{
			if ( e instanceof TypeError )
			{
				throw e;
			}

			console.log( e );
		}

		return instance;
	}
}

export function inject( ...dependecies )
{
	return function( target )
	{
		target.__inject = dependecies;
	}
}


export function autoinject( potentialTarget? ): any
{
	const deco = function( target )
	{
		const deps = Reflect['getOwnMetadata']( 'design:paramtypes', target ) || {}; // generated by TypeScript
		target.__inject = deps;
	}

	return potentialTarget ? deco( potentialTarget ) : deco;
}

class Resolver
{
	constructor()
	{}

	resolve( container: Container ): any
	{}
}


export class Instance extends Resolver
{
	constructor( public key: any )
	{
		super();
	}


	static of( key: any ): Instance
	{
		return new Instance( key );
	}

	resolve( container: Container ): any
	{
		return container.createInstance( this.key ); 
	}
}


export class Singleton extends Resolver
{
	constructor( public key: any )
	{
		super();
	}


	static of( key: any ): Singleton
	{
		return new Singleton( key );
	}


	resolve( container: Container ): any
	{
		return container.getInstance( this.key );
	}
}


export class Parent extends Resolver
{
	constructor( public key: any )
	{
		super();
	}


	static of( key: any ): Parent
	{
		return new Parent( key );
	}

	resolve( container: Container ): any
	{
		const parent = container.getParent();

		if ( ! parent )
		{
			throw new Error( `Parent container not specified!` );
		}

		return parent.get( this.key );
	}
}